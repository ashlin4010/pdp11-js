.MAIN.  MACRO V05.05   00:00  Page 1


      1                                 ; Javascript PDP 11/70 Emulator v3.2
      2                                 ; written by Paul Nankervis
      3                                 ; Please send suggestions, fixes and feedback to paulnank@hotmail.com
      4                                 ;
      5                                 ; boot loader code
      6                                 ;mac/list:boot boot
      7                                 ;link/bot:120000 boot,odt11
      8                                 ;dump/noascii/start:120/out:tt: boot.sav
      9
     10                                     .macro lda label,reg
     11                                     mov pc,reg
     12                                     add label-.,reg     ;load address relative (PIC)
     13                                     .endm
     14
     15         177776                  psw=177776
     16         177772                  pir=177772
     17         177570                  consol=177570
     18
     19 000000                          start:
     20 000000  000005                      reset
     21 000002  005037  177776              clr @#psw
     22 000006                              lda #start,sp
     23 000014  062706  020000              add #20000,sp       ;put stack at end of current page
     24
     25 000020                              lda #banner,r0
     26 000026  004767  000156              jsr pc,print        ;print banner
     27
     28 000032  162706  000256              sub #256,sp         ;make room for cmd buffer
     29 000036  010667  000242              mov sp,buffer
     30
     31 000042  004767  000010              jsr pc,getcmd       ;print prompt, start clock, read input...
     32
     33 000046  005000                      clr r0
     34 000050  000001                  20$:wait
     35 000052  005200                      inc r0
     36 000054  000775                      br 20$              ;idle loop
     37
     38 000056                          getcmd:
     39 000056                              lda #prompt,r0
     40 000064  004767  000120              jsr pc,print        ;print cmd prompt
     41
     42 000070  016767  000210  000210      mov buffer,bufptr   ;reset input buffer
     43
     44 000076                              lda #inpast,r0
     45 000104  010037  000060              mov r0,@#60
     46 000110  012737  000200  000062      mov #200,@#62
     47 000116  112737  000100  177560      movb #100,@#177560  ;set console input handler
     48
     49 000124                              lda #clkast,r0
     50 000132  010037  000100              mov r0,@#100
     51 000136  012737  000340  000102      mov #340,@#102
     52 000144  112737  000100  177546      movb #100,@#177546  ;ensure clock is ticking
     53 000152  000207                      rts pc
     54
     55 000154  000000                  clkcnt: .word 0
     56 000156                          clkast:
     57 000156  005367  177772              dec clkcnt








.MAIN.  MACRO V05.05   00:00  Page 1-1


     58 000162  016737  177766  177570      mov clkcnt,@#consol ;tickle display register
     59 000170  000006                      rtt
     60
     61 000172                          putchr:
     62 000172  105737  177564              tstb @#177564
     63 000176  100375                      bpl putchr
     64 000200  110037  177566              movb r0,@#177566    ;write a character to console terminal
     65 000204  000207                      rts pc
     66
     67 000206  000000                  prtptr: .word 0
     68 000210                          print:
     69 000210  132737  000100  177564      bitb #100,@#177564
     70 000216  001374                      bne print           ;wait until terminal ie is not set
     71 000220  010067  177762              mov r0,prtptr
     72 000224                              lda #prtast,r0
     73 000232  010037  000064              mov r0,@#64
     74 000236  012737  000200  000066      mov #200,@#66
     75 000244  012737  000100  177564      mov #100,@#177564   ;set print in motion
     76 000252  000207                      rts pc
     77
     78 000254                          prtast:
     79 000254  105777  177726              tstb @prtptr        ;check for end of string
     80 000260  001406                      beq 20$
     81 000262  117737  177720  177566      movb @prtptr,@#177566
     82 000270  005267  177712              inc prtptr
     83 000274  000006                      rtt
     84 000276  105037  177564          20$:clrb @#177564      ;turn off ie
     85 000302  000006                      rtt
     86
     87 000304  000000                  buffer: .word 0 ;input buffer location
     88 000306  000000                  bufptr: .word 0 ;input buffer pointer
     89
     90 000310                          inpast:
     91 000310  010046                      mov r0,-(sp)
     92 000312  010146                      mov r1,-(sp)
     93 000314  113700  177562              movb @#177562,r0    ;get character
     94 000320  120027  000040              cmpb r0,#40
     95 000324  002432                      blt 30$             ;below space?
     96 000326  120027  000177              cmpb r0,#127.
     97 000332  002034                      bge 50$             ;above del? go test equality
     98 000334  016701  177746              mov bufptr,r1
     99 000340  166701  177740              sub buffer,r1
    100 000344  020127  000250              cmp r1,#250
    101 000350  003060                      bgt 90$             ;no room in buffer?
    102 000352  004767  177614              jsr pc,putchr       ;echo the char
    103 000356  120027  000141              cmpb r0,#97.
    104 000362  002405                      blt 10$             ;less than lower 'a'
    105 000364  120027  000172              cmpb r0,#122.
    106 000370  003002                      bgt 10$             ;greater than lower 'z'
    107 000372  142700  000040              bicb #40,r0         ;convert to upper case
    108 000376  016701  177704          10$:mov bufptr,r1
    109 000402  110021                      movb r0,(r1)+       ;put character in buffer
    110 000404  010167  177676              mov r1,bufptr
    111 000410  000440                      br  90$
    112
    113 000412  120027  000015          30$:cmpb r0,#15
    114 000416  001417                      beq 80$             ;for carriage return do a command








.MAIN.  MACRO V05.05   00:00  Page 1-2


    115 000420  120027  000010              cmpb r0,#10
    116 000424  001032                  50$:bne 90$             ;is it <del> or back space
    117 000426  026767  177654  177650      cmp bufptr,buffer   ;any data to remove?
    118 000434  101426                      blos 90$
    119 000436  005367  177644              dec bufptr
    120 000442                              lda #del,r0         ;backspace to delete character
    121 000450  004767  177534              jsr pc,print
    122 000454  000416                      br 90$
    123
    124 000456  016700  177624          80$:mov bufptr,r0
    125 000462  105010                      clrb (r0)
    126 000464                              lda #cmd,r0
    127 000472  010037  000240              mov r0,@#240
    128 000476  012737  000040  000242      mov #40,@#242
    129 000504  012737  001000  177772      mov #1000,@#pir     ;call cmd at priority 1 using pir
    130
    131 000512  012601                  90$:mov (sp)+,r1        ;restore registers & exit
    132 000514  012600                      mov (sp)+,r0
    133 000516  000006                      rtt
    134
    135 000520                          cmd:
    136 000520  005037  177772              clr @#pir           ; no more pir calls
    137 000524  010046                      mov r0,-(sp)
    138 000526  010146                      mov r1,-(sp)
    139 000530  010246                      mov r2,-(sp)
    140 000532  010346                      mov r3,-(sp)
    141 000534  010446                      mov r4,-(sp)
    142 000536  010546                      mov r5,-(sp)
    143
    144 000540                              lda #eol,r0
    145 000546  004767  177436              jsr pc,print
    146
    147 000552  016705  177526              mov buffer,r5       ;check cmd in buffer (it is uppercase only!)
    148 000556  112504                  20$:movb (r5)+,r4
    149 000560  001453                      beq 90$             ;done if end
    150 000562  020427  000040              cmp r4,#40
    151 000566  001773                      beq 20$             ;skip spaces
    152
    153 000570  005003                      clr r3              ;command index
    154 000572                              lda #cmdlst,r0      ;command names
    155
    156 000600  112001                  30$:movb (r0)+,r1       ;get first command table byte
    157 000602  001435                      beq 80$             ;end so unknown cmd
    158 000604  120104                      cmpb r1,r4
    159 000606  001013                      bne 50$             ;if no match next command
    160
    161 000610  010502                      mov r5,r2
    162 000612  111201                  40$:movb (r2),r1        ;look at other command bytes
    163 000614  001415                      beq  70$
    164 000616  005202                      inc r2
    165 000620  020127  000040              cmp r1,#40
    166 000624  001411                      beq 70$
    167 000626  105710                      tstb (r0)
    168 000630  001402                      beq  50$
    169 000632  120120                      cmpb r1,(r0)+       ;compare input byte with table
    170 000634  001766                      beq 40$
    171








.MAIN.  MACRO V05.05   00:00  Page 1-3


    172 000636  105720                  50$:tstb (r0)+          ;find next table command
    173 000640  001376                      bne 50$
    174 000642  062703  000002              add #2,r3
    175 000646  000754                      br 30$
    176
    177 000650  132737  000100  177564  70$:bitb #100,@#177564
    178 000656  001374                      bne 70$             ;wait for printing before executing
    179 000660                              lda #cmdtbl,r0      ;execute command routine at r3 offset
    180 000666  060003                      add r0,r3
    181 000670  061303                      add (r3),r3
    182 000672  004713                      jsr pc,(r3)
    183 000674  000405                      br 90$
    184
    185 000676                          80$:lda #unkmsg,r0      ;unknown command
    186 000704  004767  177300              jsr pc,print
    187
    188 000710  004767  177142          90$:jsr pc,getcmd       ;print prompt, and ensure everything is running
    189
    190 000714  012605                      mov (sp)+,r5
    191 000716  012604                      mov (sp)+,r4
    192 000720  012603                      mov (sp)+,r3
    193 000722  012602                      mov (sp)+,r2
    194 000724  012601                      mov (sp)+,r1
    195 000726  012600                      mov (sp)+,r0
    196 000730  000006                      rtt
    197
    198 000732  001520  000456  000502  cmdtbl: .word boot-.,help-.,lights-.,chaser-.,odt-.
        000740  000466  000000C
    199 000744     120     141     165  banner: .asciz 'Paul Nankervis - paulnank@hotmail.com'<15><12><15><12>
        000747     154     040     116
        000752     141     156     153
        000755     145     162     166
        000760     151     163     040
        000763     055     040     160
        000766     141     165     154
        000771     156     141     156
        000774     153     100     150
        000777     157     164     155
        001002     141     151     154
        001005     056     143     157
        001010     155     015     012
        001013     015     012     000
    200 001016     102     157     157  prompt: .asciz 'Boot> '
        001021     164     076     040
        001024     000
    201 001025     103     157     155  hlpmsg: .ascii 'Commands are BOOT, HELP, LIGHTS, CHASER, ODT'<15><12>
        001030     155     141     156
        001033     144     163     040
        001036     141     162     145
        001041     040     102     117
        001044     117     124     054
        001047     040     110     105
        001052     114     120     054
        001055     040     114     111
        001060     107     110     124
        001063     123     054     040
        001066     103     110     101








.MAIN.  MACRO V05.05   00:00  Page 1-4


        001071     123     105     122
        001074     054     040     117
        001077     104     124     015
        001102     012
    202 001103     102     157     157          .ascii 'Boot devices are RK RL RP TM or PR'<15><12>
        001106     164     040     144
        001111     145     166     151
        001114     143     145     163
        001117     040     141     162
        001122     145     040     122
        001125     113     040     122
        001130     114     040     122
        001133     120     040     124
        001136     115     040     157
        001141     162     040     120
        001144     122     015     012
    203 001147     145     147     056          .asciz 'eg. Boot> BOOT RP1'<15><12><15><12>
        001152     040     102     157
        001155     157     164     076
        001160     040     102     117
        001163     117     124     040
        001166     122     120     061
        001171     015     012     015
        001174     012     000
    204 001176     015     012     000  eol:    .byte 15,12,0
    205 001201     010     040     010  del:    .byte 10,40,10,0;
        001204     000
    206 001205     102     117     117  cmdlst: .asciz 'BOOT'
        001210     124     000
    207 001212     110     105     114          .asciz 'HELP'
        001215     120     000
    208 001217     114     111     107          .asciz 'LIGHTS'
        001222     110     124     123
        001225     000
    209 001226     103     110     101          .asciz 'CHASER'
        001231     123     105     122
        001234     000
    210 001235     117     104     124          .asciz 'ODT'
        001240     000
    211 001241     000                          .byte 0
    212 001242     126     141     154  unkmsg: .asciz 'Valid commands are BOOT, HELP, LIGHTS, CHASER, ODT'<12><15>
        001245     151     144     040
        001250     143     157     155
        001253     155     141     156
        001256     144     163     040
        001261     141     162     145
        001264     040     102     117
        001267     117     124     054
        001272     040     110     105
        001275     114     120     054
        001300     040     114     111
        001303     107     110     124
        001306     123     054     040
        001311     103     110     101
        001314     123     105     122
        001317     054     040     117
        001322     104     124     012








.MAIN.  MACRO V05.05   00:00  Page 1-5


        001325     015     000
    213 001327     126     141     154  badboo: .asciz 'Valid boot devices are RK RL RP TM and PR eg rk0'<12><15>
        001332     151     144     040
        001335     142     157     157
        001340     164     040     144
        001343     145     166     151
        001346     143     145     163
        001351     040     141     162
        001354     145     040     122
        001357     113     040     122
        001362     114     040     122
        001365     120     040     124
        001370     115     040     141
        001373     156     144     040
        001376     120     122     040
        001401     145     147     040
        001404     162     153     060
        001407     012     015     000
    214
    215                                         .even
    216
    217 001412                          help:
    218 001412                              lda #hlpmsg,r0      ;help message
    219 001420  004767  176564              jsr pc,print
    220 001424  000207                      rts pc
    221
    222 001426                          chaser:
    223 001426  012700  000001              mov #1,r0
    224 001432  006100                      rol r0
    225 001434  000005                      reset               ;loop forever chasing the light
    226 001436  000775                      br .-4
    227
    228         177572                  mmr0=177572             ;memory management control registers
    229         177574                  mmr1=177574
    230         177576                  mmr2=177576
    231         172516                  mmr3=172516
    232         172300                  mmrk=172300
    233         172200                  mmrs=172200
    234         177600                  mmru=177600
    235         000004                  modes=4 ;page address register table size
    236
    237 001440                          lights:
    238 001440  005037  177572              clr @#mmr0          ;turn off mmu
    239 001444                              lda #mmupar,r5      ;get mmu page address register table
    240 001452  012704  000004              mov #modes,r4       ;number of table entries
    241 001456  012503                  10$:mov (r5)+,r3        ;get page address register base for mode
    242 001460  100007                      bpl 20$             ;skip dummy entry for illegal mode
    243 001462  005001                      clr r1              ;set base virtual relocation address to 0
    244 001464  010302                      mov r3,r2           ;pass page register address to subroutine
    245 001466  004767  000152              jsr pc,90$          ;initialize all map pdr & par registers for mode
    246 001472  012763  177600  000076      mov #177600,76(r3)  ;point last d page (8) to i/o space
    247 001500  077412                  20$:sob r4,10$          ;repeat for all modes
    248 001502  012737  000007  172516      mov #7,@#mmr3       ;set mmu for 18 bit addressing with split i/d
    249 001510  012737  000001  177572      mov #1,@#mmr0       ;enable memory mapping
    250
    251 001516  012700  004000              mov #4000,r0        ;relocation address for light virtual code (upper mem somewhere)
    252 001522  010037  172244              mov r0,@#mmrs+44    ;super mode page 2 i relocation base (becomes i virtual #40000)








.MAIN.  MACRO V05.05   00:00  Page 1-6


    253 001526  010037  172264              mov r0,@#mmrs+64    ;super mode page 2 d relocation base
    254 001532  042737  030000  177776      bic #030000,@#psw   ;clear previous mode in psw
    255 001540  052737  010000  177776      bis #010000,@#psw   ;set pm to super
    256 001546  012703  040200              mov #40200,r3       ;target virtual address for code (allowing 200 for data)
    257 001552                              lda #vcode,r2       ;where we get virtual code
    258 001560                              lda #vcoded,r0      ;end of virtual code
    259 001566  012246                  30$:mov (r2)+,-(sp)     ;get a word of code
    260 001570  006623                      mtpi (r3)+          ;push into super space
    261 001572  020200                      cmp r2,r0           ;push all code to target space
    262 001574  103774                      blo 30$             ;until done
    263
    264 001576  012746  040200              mov #40200,-(sp)
    265 001602  006606                      mtpi sp             ;set super sp
    266 001604  052737  030000  177776      bis #030000,@#psw
    267 001612  012746  040140              mov #40140,-(sp)
    268 001616  006606                      mtpi sp             ;set user sp (no further sp handling needed)
    269 001620  012737  040200  000240      mov #40200,@#240    ;start address for super pc
    270 001626  012737  054040  000242      mov #054040,@#242   ;super mode will use alternate registers
    271 001634  012737  001000  177772      mov #1000,@#pir     ;call #40200 in super mode at priority 1 using pir
    272 001642  000207                      rts pc              ;our work here is done
    273
    274 001644  012700  000010          90$:mov #8.,r0          ;subroutine to set up mapping pdr/par registers at r2 with r1 base address
    275 001650  010162  000060          95$:mov r1,60(r2)       ;load d par
    276 001654  010162  000040              mov r1,40(r2)       ;load i par
    277 001660  012762  077406  000020      mov #77406,20(r2)   ;load d pdr as full length read/write page
    278 001666  012722  077406              mov #77406,(r2)+    ;load i pdr
    279 001672  062701  000200              add #200,r1         ;step base address
    280 001676  077014                      sob r0,95$          ;repeat
    281 001700  000207                      rts pc
    282
    283                                 ;this code is copied to the target mode virtual address #40200 (on page 2)
    284                                 ;virtual addresses #40000 to #40101 reserved for wait & jmp instructions
    285 001702                          vcode:
    286 001702  005037  177772              clr @#pir           ;turn off pir
    287 001706  042737  000340  177776      bic #340,@#psw      ;lower priority
    288 001714  012700  000037              mov #37,r0          ;load initial display pattern (r0 displays in console data paths)
    289 001720  012701  174000              mov #174000,r1      ;load initial address pattern (r1 displays as the virtual address
    290                                                         ;                              of an instruction following a wait)
    291
    292 001724  013703  177776          10$:mov @#psw,r3        ;get current psw
    293 001730  004767  000432              jsr pc,ps2par       ;convert r3 psw to mmu page register base in r2
    294 001734  010205                      mov r2,r5           ;store result
    295
    296 001736  010102                      mov r1,r2           ;get address to display
    297 001740  162702  000002              sub #2,r2           ;compute address of wait instruction
    298 001744  010203                      mov r2,r3           ;copy address to make offset
    299 001746  042703  177701              bic #177701,r3      ;make 6 bit page offset (without low bit!)
    300 001752  012763  000001  040000      mov #0000001,40000(r3)  ;write wait instruction
    301 001760  012763  000113  040002      mov #0000113,40002(r3)  ;write jmp (r3) instruction
    302
    303 001766  010203                      mov r2,r3           ;make relocation base for wait/jmp
    304 001770  042703  160077              bic #160077,r3      ;from 7 middle address bits
    305 001774  072327  177772              ash #-6,r3          ;move into position
    306 002000  016504  000044              mov 44(r5),r4       ;get existing i page 2 base
    307 002004  160304                      sub r3,r4           ;calculate new relocation base for wait/jmp
    308
    309 002006  072227  177764              ash #-12.,r2        ;3 top bits of wait address are wait page








.MAIN.  MACRO V05.05   00:00  Page 1-7


    310 002012  042702  177761              bic #177761,r2      ;convert to word index
    311 002016  010103                      mov r1,r3           ;address for jmp instruction (2 after wait)
    312 002020  072327  177764              ash #-12.,r3        ;3 top bits are jmp page number
    313 002024  042703  177761              bic #177761,r3      ;convert to word index
    314 002030  020302                      cmp r3,r2           ;both on same page?
    315 002032  001403                      beq 20$             ;yes jmp doesn't need own par
    316 002034  060503                      add r5,r3           ;address of jmp mmu par
    317 002036  010463  000040              mov r4,40(r3)       ;set relocation base for jmp i page
    318 002042  060502                  20$:add r5,r2           ;address of wait mmu par
    319 002044  010462  000040              mov r4,40(r2)       ;set relocation base for wait i page
    320
    321 002050  010102                      mov r1,r2           ;get address to display
    322 002052  162702  000002              sub #2,r2           ;compute address of wait instruction
    323 002056  042702  000001              bic #1,r2           ;no odd instruction addresses please :-(
    324 002062                              lda #32$,r3         ;put jmp return address into r3
    325 002070  012704  000003              mov #3,r4           ;repeat count
    326 002074  000112                  30$:jmp (r2)            ;jmp to wait
    327 002076  077402                  32$:sob r4,30$          ;jmp (r3) comes back here
    328
    329 002100  032737  000001  177570      bit #1,@#consol     ;change rotation directon on switch bit zero
    330 002106  001004                      bne 40$
    331 002110  006101                      rol r1              ;rotate pattern anticlockwise
    332 002112  006000                      ror r0
    333 002114  005501                      adc r1
    334 002116  000403                      br 50$
    335 002120  006100                  40$:rol r0              ;rotate pattern clockwise
    336 002122  006001                      ror r1
    337 002124  005500                      adc r0
    338
    339 002126  020027  000037          50$:cmp r0,#37          ;check if start of pattern
    340 002132  001274                      bne 10$             ;if not we are done
    341
    342
    343 002134  032737  000002  177570      bit #2,@#consol     ;don't change CPU mode if switch bit one
    344 002142  001023                      bne 60$
    345
    346 002144  013703  177776              mov @#psw,r3        ;get current psw
    347 002150  004767  000212              jsr pc,ps2par       ;convert r3 psw to mmu page register base in r2
    348 002154  016205  000044              mov 44(r2),r5       ;get current mode i page 2 relocation base
    349 002160  062703  040000              add #040000,r3      ;increment cpu mode
    350 002164  100002                      bpl 55$
    351 002166  052703  040000              bis #040000,r3      ;skip illegal mode 2
    352 002172  004767  000170          55$:jsr pc,ps2par       ;convert new r3 psw to mmu page register base in r2
    353 002176  010562  000064              mov r5,64(r2)       ;set new mode d page 2 relocation base
    354 002202  010562  000044              mov r5,44(r2)       ;set new mode i page 2 relocation base
    355 002206  010337  177776              mov r3,@#psw        ;set new mode
    356
    357
    358 002212  032737  000004  177570  60$:bit #4,@#consol     ;don't fiddle with physical addressing if switch bit two
    359 002220  001401                      beq 70$
    360 002222  000640                  65$:br  10$             ;stepping stone for code below which has a branch too far
    361
    362 002224  013703  177776          70$:mov @#psw,r3        ;get current psw
    363 002230  004767  000132              jsr pc,ps2par       ;convert r3 psw to mmu page register base in r2
    364 002234  016205  000044              mov 44(r2),r5       ;get current mode i page 2 relocation base
    365
    366 002240  000257                      ccc                 ;0 fill








.MAIN.  MACRO V05.05   00:00  Page 1-8


    367 002242  006005                      ror r5              ;rotate relocation base right
    368 002244  042705  000077              bic #077,r5         ;test for as far down as we dare go
    369 002250  001020                      bne 85$             ;if still ok use it
    370
    371 002252  032737  000010  177570      bit #10,@#consol    ;don't adjust 18/22 addressing if switch bit four
    372 002260  001004                      bne 80$
    373 002262  012703  000020              mov #20,r3          ;mmr3 22 bit mask
    374 002266  074337  172516              xor r3,@#mmr3       ;toggle 18/22 bit addressing
    375
    376 002272  012705  004000          80$:mov #4000,r5        ;assume an 18 bit relocation address
    377 002276  032737  000020  172516      bit #20,@#mmr3      ;ok if in 18 bit mode
    378 002304  001402                      beq 85$
    379 002306  012705  100000              mov #100000,r5      ;use a bigger relocation address for 22 bit
    380
    381 002312  010562  000062          85$:mov r5,62(r2)       ;set the relocation base for d page 1 (output target area)
    382 002316                              lda #vcoded,r3      ;get code end address (somewhere in page 2)
    383 002324  162703  040000              sub #40000,r3       ;convert to byte count from page 2 start
    384 002330  006203                      asr r3              ;then word count
    385 002332  012704  020000              mov #20000,r4       ;begin at the start address of page 1
    386 002336  016424  020000          90$:mov 20000(r4),(r4)+ ;copy a word from page 2 to page 1
    387 002342  077303                      sob r3,90$          ;repeat
    388
    389 002344  010562  000064              mov r5,64(r2)       ;set mode d page 2 relocation base
    390 002350  010562  000044              mov r5,44(r2)       ;set mode i page 2 relocation base
    391 002354  000722                      br 65$              ;our work here is done
    392
    393
    394 002356  172300  172200  000001  mmupar: .word mmrk,mmrs,1,mmru  ; mmu page address register table by mode (note entry for ill
        002364  177600
    395 002366                          ps2par:                 ;subroutine to convert psw (r3) to mmu page register base address (r2)
    396 002366  010302                      mov r3,r2           ;don't clobber r3!
    397 002370  072227  177763              ash #-13.,r2        ;shift psw mode to bits 2 and 1
    398 002374  042702  177771              bic #177771,r2      ;clear other junk
    399 002400  060702                      add pc,r2           ;get relative address of
    400 002402  062702  177754              add #mmupar-.,r2    ;page address register table entry
    401 002406  011202                      mov (r2),r2         ;return mmu page register base for psw in r2
    402 002410  000207                      rts pc              ;done
    403
    404 002412                          vcoded:                 ;end of virtual mode code
    405
    406 002412  000274  000210  000322  bootbl: .word bootrk-.,bootrl-.,bootrp-.,boottm-.,bootpt-.
        002420  000410  000556
    407 002424     122     113     122  boolst: .ascii 'RKRLRPTMPR'
        002427     114     122     120
        002432     124     115     120
        002435     122
    408 002436  000000                          .word 0
    409 002440  000005  000003  000004  boount: .word 5, 3, 4, 3, 0
        002446  000003  000000
    410 002452                          boot:
    411 002452  112204                  10$:movb (r2)+,r4
    412 002454  120427  000040              cmpb r4,#40
    413 002460  001774                      beq 10$             ;ignore leading spaces
    414 002462  105704                      tstb r4
    415 002464  001451                      beq 80$             ;must have a char
    416 002466  112200                      movb (r2)+,r0
    417 002470  001447                      beq 80$             ;must have two








.MAIN.  MACRO V05.05   00:00  Page 1-9


    418 002472  000300                      swab r0
    419 002474  050004                      bis r0,r4           ;combine two characters (ie rk, rl..)
    420
    421 002476  005003                      clr r3              ;unit
    422 002500  112200                  20$:movb (r2)+,r0
    423 002502  001411                      beq 30$
    424 002504  162700  000060              sub #'0,r0
    425 002510  120027  000007              cmpb r0,#7
    426 002514  101035                      bhi 80$
    427 002516  072327  000003              ash #3,r3
    428 002522  150003                      bisb r0,r3          ;get any unit number digits
    429 002524  000765                      br 20$
    430
    431 002526  005002                  30$:clr r2              ;name index
    432 002530                              lda #boolst,r0
    433 002536  012001                  40$:mov (r0)+,r1        ;get bootname
    434 002540  001423                      beq 80$
    435 002542  020104                      cmp r1,r4           ;match?
    436 002544  001403                      beq 50$
    437 002546  062702  000002              add #2,r2
    438 002552  000771                      br 40$
    439
    440 002554                          50$:lda #boount,r0
    441 002562  060200                      add r2,r0
    442 002564  020310                      cmp r3,(r0)
    443 002566  003010                      bgt 80$             ;unit out of range
    444
    445 002570  000005                      reset
    446 002572                              lda #bootbl,r0      ;execute command routine at r2 offset
    447 002600  060002                      add r0,r2
    448 002602  061202                      add (r2),r2
    449 002604  004712                      jsr pc,(r2)
    450 002606  000405                      br 90$
    451
    452 002610                          80$:lda #badboo,r0      ;complain we don't know boot device
    453 002616  004767  175366              jsr pc,print
    454
    455 002622  000207                  90$:rts pc
    456
    457         174400                  rlcs=174400
    458 002624                          bootrl:
    459 002624  000303                      swab r3         ; unit number
    460 002626  012700  174400              mov #rlcs,r0    ; csr
    461 002632  012760  000013  000004      mov #13,4(r0)   ; seek
    462 002640  052703  000004              bis #4,r3       ; unit+gstat
    463 002644  010310                      mov r3,(r0)     ; issue cmd
    464 002646  105710                      tstb (r0)       ; wait
    465 002650  100376                      bpl .-2
    466 002652  005060  000002              clr 2(r0)       ; clr ba
    467 002656  005060  000004              clr 4(r0)       ; clr da
    468 002662  012760  177000  000006      mov #-512.,6(r0) ; set wc
    469 002670  105003                      clrb r3
    470 002672  052703  000014              bis #14,r3      ; unit+read
    471 002676  010310                      mov r3,(r0)     ; issue cmd
    472 002700  105710                      tstb (r0)       ; wait
    473 002702  100376                      bpl .-2
    474 002704  005007                      clr pc








.MAIN.  MACRO V05.05   00:00  Page 1-10


    475
    476         177412                  rkda=177412
    477 002706                          bootrk:
    478 002706  012700  177412              mov #rkda,r0    ; csr
    479 002712  072327  000015              ash #13.,r3     ; unit # into da
    480 002716  010310                      mov r3,(r0)     ; load da
    481 002720  005040                      clr -(r0)       ; clear ba
    482 002722  012740  177000              mov #-256.*2,-(r0) ; load wc
    483 002726  012740  000005              mov #5,-(r0)    ; read & go
    484 002732  105710                      tstb (r0)
    485 002734  100376                      bpl .-2
    486 002736  005007                      clr pc
    487
    488         176700                  rpcsr=0176700
    489 002740                          bootrp:
    490 002740  012701  176700              mov #rpcsr, r1
    491 002744  012761  000040  000010      mov #40, 10(r1)      ; reset
    492 002752  010361  000010              mov r3, 10(r1)       ; set unit
    493 002756  012711  000021              mov #0000021, (r1)   ; pack ack
    494 002762  012761  010000  000032      mov #0010000, 32(r1) ; 16b mode
    495 002770  012761  177000  000002      mov #-512., 2(r1)    ; set wc
    496 002776  005061  000004              clr 4(r1)            ; clr ba
    497 003002  005061  000006              clr 6(r1)            ; clr da
    498 003006  005061  000034              clr 34(r1)           ; clr cyl
    499 003012  012711  000071              mov #0000071, (r1)   ; read
    500 003016  105711                      tstb (r1)            ; wait
    501 003020  100376                      bpl .-2
    502 003022  105011                      clrb (r1)
    503 003024  010300                      mov r3,r0            ;required for BSD
    504 003026  005007                      clr pc
    505
    506
    507         172526                  mtcma=0172526
    508 003030                          boottm:
    509 003030  010300                      mov r3, r0          ; unit
    510 003032  012701  172526              mov #mtcma, r1      ; mtcma
    511 003036  005011                      clr (r1)
    512 003040  012741  177777              mov #-1, -(r1)      ; mtbrc
    513 003044  010002                      mov r0,r2
    514 003046  000302                      swab r2
    515 003050  062702  060011              add #60011, r2
    516 003054  010241                      mov r2, -(r1)       ; space + go
    517 003056  105711                      tstb (r1)           ; mtc
    518 003060  100376                      bpl .-2
    519 003062  010002                      mov r0,r2
    520 003064  000302                      swab r2
    521 003066  062702  060003              add #60003, r2
    522 003072  010211                      mov r2, (r1)        ; read + go
    523 003074  105711                      tstb (r1)           ; mtc
    524 003076  100376                      bpl .-2
    525 003100  005007                      clr pc
    526
    527                                 ;Paper tape boot routine using RT11 LDA format
    528                                 ;Input format:
    529                                 ;Frame
    530                                 ;  1    001
    531                                 ;  2    000








.MAIN.  MACRO V05.05   00:00  Page 1-11


    532                                 ;  3    Low order byte count    (Includes all except checksum,
    533                                 ;  4    High order byte count       even the 001 000.)
    534                                 ;  5    Low order load address
    535                                 ;  6    High order load address
    536                                 ;  7..  Data bytes
    537                                 ;  XXX  Checksum    (Includes all the block - even the 001)
    538                                 ;
    539                                 ;The checksum is calculated such that when all the bytes have
    540                                 ;been added up, the low byte of the sum will be zero.
    541                                 ;
    542                                 ;If the byte count is 6, the load address specified will be
    543                                 ;taken to be the start address of the program. If the address
    544                                 ;is even the program will be started, otherwise ODT will be
    545                                 ;re-entered.  If (count > 6), the data block will be loaded.
    546                                 ;
    547                                 ;This is the format used by DEC for paper tapes, and can be
    548                                 ;produced using the RT-11 LINK/LDA command.
    549
    550                                 ;Register use:
    551                                 ; R0 - input byte       R1 - checksum
    552                                 ; R2 - load address     R3 - byte count
    553                                 ; R4 - start address flag
    554
    555         177550                  ptrcsr = 177550 ;Address of reader device
    556
    557 003102     120     141     160  pterr:.asciz 'Paper tape checksum error'<15><12>
        003105     145     162     040
        003110     164     141     160
        003113     145     040     143
        003116     150     145     143
        003121     153     163     165
        003124     155     040     145
        003127     162     162     157
        003132     162     015     012
        003135     000
    558 003136     120     141     160  ptnost:.asciz 'Paper tape has no start address'<15><12>
        003141     145     162     040
        003144     164     141     160
        003147     145     040     150
        003152     141     163     040
        003155     156     157     040
        003160     163     164     141
        003163     162     164     040
        003166     141     144     144
        003171     162     145     163
        003174     163     015     012
        003177     000
    559                                 .even
    560
    561 003200                          bootpt:
    562 003200  005001                  10$:clr r1              ;Initialize checksum
    563 003202  004767  000124              jsr pc,getch
    564 003206  120027  000001              cmpb r0,#1          ;Read until start of frame
    565 003212  001372                      bne 10$
    566 003214  004767  000112              jsr pc,getch
    567 003220  105700                      tstb r0             ;Byte after start must be zero
    568 003222  001366                      bne 10$








.MAIN.  MACRO V05.05   00:00  Page 1-12


    569
    570 003224  004767  000062              jsr pc,getwd
    571 003230  010203                      mov r2,r3           ;Get byte count in R3
    572 003232  004767  000054              jsr pc,getwd        ;Get load address in R2
    573 003236  063702  177570              add @#consol,r2     ;Add switches for relocation
    574
    575 003242  162703  000006              sub #6,r3
    576 003246  010304                      mov r3,r4           ;Flag whether there is data
    577 003250  003404                      ble 40$             ;If no data then must be a start address
    578
    579 003252  004767  000054          30$:jsr pc,getch
    580 003256  110022                      movb r0,(r2)+       ;Put byte into memory
    581 003260  077304                      sob r3,30$
    582
    583 003262  004767  000044          40$:jsr pc,getch
    584 003266  105701                      tstb r1             ;Verify checksum
    585 003270  001034                      bne chkerr
    586
    587 003272  005704                      tst r4
    588 003274  003341                      bgt 10$             ;If that frame contained data go get more
    589
    590 003276  005702                      tst r2
    591 003300  001434                      beq nostrt          ;If load address null then don't start
    592 003302  032702  000001              bit #1,r2
    593 003306  001031                      bne nostrt          ;If load address odd then don't start
    594
    595 003310  000112                      jmp (r2)            ;See what happens
    596
    597 003312                          getwd:                  ;Get a word from reader in R2
    598 003312  004767  000014              jsr pc,getch
    599 003316  010002                      mov r0,r2           ;Low order
    600 003320  004767  000006              jsr pc,getch
    601 003324  000300                      swab r0
    602 003326  050002                      bis r0,r2           ;Hi order
    603 003330  000207                      rts pc
    604
    605 003332                          getch:                  ;Get a character from reader in R0
    606 003332  012700  177550              mov #ptrcsr,r0      ;Reader device
    607 003336  012710  000001              mov #1,(r0)         ;Start reader
    608 003342  105710                  1$: tstb (r0)
    609 003344  100376                      bpl 1$              ;Wait for a character
    610 003346  116000  000002              movb 2(r0),r0       ;Get it
    611 003352  042700  177400              bic #177400,r0
    612 003356  060001                      add r0,r1           ;Accumulate checksum
    613 003360  000207                      rts pc
    614
    615 003362                          chkerr:
    616 003362                              lda #pterr,r0
    617 003370  000403                      br ptend
    618
    619 003372                          nostrt:
    620 003372                              lda #ptnost,r0
    621 003400                          ptend:
    622 003400  004767  174604              jsr pc,print
    623 003404  000207                      rts pc
    624
    625 003406  000000'                 end: .end start








.MAIN.  MACRO V05.05   00:00  Page 1-13
Symbol table

BADBOO  001327R         CHASER  001426R         GETWD   003312R         MMUPAR  002356R         PTEND   003400R
BANNER  000744R         CHKERR  003362R         HELP    001412R         MODES = 000004          PTERR   003102R
BOOLST  002424R         CLKAST  000156R         HLPMSG  001025R         MTCMA = 172526          PTNOST  003136R
BOOT    002452R         CLKCNT  000154R         INPAST  000310R         NOSTRT  003372R         PTRCSR= 177550
BOOTBL  002412R         CMD     000520R         LIGHTS  001440R         ODT   = ****** GX       PUTCHR  000172R
BOOTPT  003200R         CMDLST  001205R         MMRK  = 172300          PIR   = 177772          RKDA  = 177412
BOOTRK  002706R         CMDTBL  000732R         MMRS  = 172200          PRINT   000210R         RLCS  = 174400
BOOTRL  002624R         CONSOL= 177570          MMRU  = 177600          PROMPT  001016R         RPCSR = 176700
BOOTRP  002740R         DEL     001201R         MMR0  = 177572          PRTAST  000254R         START   000000R
BOOTTM  003030R         END     003406R         MMR1  = 177574          PRTPTR  000206R         UNKMSG  001242R
BOOUNT  002440R         EOL     001176R         MMR2  = 177576          PSW   = 177776          VCODE   001702R
BUFFER  000304R         GETCH   003332R         MMR3  = 172516          PS2PAR  002366R         VCODED  002412R
BUFPTR  000306R         GETCMD  000056R

. ABS.  000000    000   (RW,I,GBL,ABS,OVR)
        003406    001   (RW,I,LCL,REL,CON)
Errors detected:  0

*** Assembler statistics


Work  file  reads: 0
Work  file writes: 0
Size of work file: 8292 Words  ( 33 Pages)
Size of core pool: 13312 Words  ( 52 Pages)
Operating  system: RT-11

Elapsed time: 00:00:00.05
DK:BOOT,DK:BOOT=DK:BOOT


.